# 22. 엔드포인트 라우팅

Xvelte는 서버 API 엔드포인트를 생성하기 위한 두 가지 방법을 제공합니다: **프로그래밍 방식**과 **파일 시스템 기반 방식**입니다. 두 방법 모두 Express.js와 유사한 방식으로 작동하며, 함께 사용 시 프로그래밍 방식이 더 높은 우선순위를 가집니다.

## 1. 프로그래밍 방식 라우팅

`XvelteApp` 인스턴스에서 HTTP 메소드에 해당하는 메소드를 사용하여 엔드포인트 핸들러를 직접 등록하는 방식입니다.

-   `app.get(path, handler)`
-   `app.post(path, handler)`
-   `app.put(path, handler)`
-   `app.delete(path, handler)`
-   `app.all(path, handler)`: 모든 메소드 처리

```ts
// src/app.ts (애플리케이션 시작 파일)

// GET /api/items
app.get('/api/items', (event) => {
  const items = [{ id: 1, name: 'Xvelte' }];
  event.setHeader('Content-Type', 'application/json');
  return JSON.stringify(items);
});

// POST /api/items
app.post('/api/items', async (event) => {
  const newItem = await event.json();
  event.status = 201;
  event.setHeader('Content-Type', 'application/json');
  return JSON.stringify({ success: true, message: 'Item created' });
});
```

## 2. 파일 시스템 기반 라우팅

`src/routes` 디렉토리 안에 `+server.ts` 파일을 만들고, 그 안에 HTTP 메소드 이름(대문자)으로 함수를 `export`하여 엔드포인트를 정의하는 방식입니다.

`XvelteApp` 인스턴스에서 `useFileBaseRouter` 비동기 메소드를 호출하여 사용할 수 있습니다.

프로덕션에서는 `XvelteApp` 인스턴스에서 `useFileBaseRouter` 메소드를 호출할 때 핸들러가 등록되나, 개발 서버에서는 프로그래밍 방식 라우팅보다 먼저 등록되어 우선순위가 낮습니다. 따라서 프로그래밍 방식 라우팅 이전에 메소드를 호출하여 먼저 파일 기반 라우팅을 먼저 사용하는 것을 추천합니다. 

### 기본 구조

`+server.ts` 파일 하나에 여러 메소드 핸들러를 동시에 정의할 수 있습니다.

```ts
// src/app.ts
...
const app = new XvelteApp(template);

// 이 비동기 메소드를 호출해야합니다.
await app.useFileBaseRouter();
...
```

```typescript
// src/routes/api/todos/+server.ts

import type { RequestEvent } from '@hotsixman/xvelte';

// 임시 데이터베이스
let todos = [{ id: 1, text: 'Xvelte 공부하기' }];

// GET /api/todos
export function GET(event: RequestEvent) {
    event.setHeader('Content-Type', 'application/json');
    return JSON.stringify(todos);
}

// POST /api/todos
export async function POST(event: RequestEvent) {
    const { text } = await event.json();
    const newTodo = { id: Date.now(), text };
    todos.push(newTodo);

    event.status = 201; // Created
    event.setHeader('Content-Type', 'application/json');
    return JSON.stringify(newTodo);
}
```

### 동적 라우팅

파일 경로에 대괄호(`[]`)를 사용하여 동적 파라미터를 처리할 수 있습니다. 파라미터는 `event.params` 객체를 통해 접근할 수 있습니다.

```typescript
// src/routes/api/todos/[id]/+server.ts

// DELETE /api/todos/:id
export function DELETE(event: RequestEvent) {
    const id = Number(event.params.id);
    todos = todos.filter(todo => todo.id !== id);
    
    event.status = 204; // No Content
    return null;
}
```

## `RequestEvent`와 핸들러 반환 값

모든 엔드포인트 핸들러는 `RequestEvent` 객체를 인자로 받으며, 이를 통해 요청을 분석하고 응답을 제어할 수 있습니다. 자세한 내용은 [RequestEvent](./23.%20RequestEvent.md) 문서를 참고하세요.

핸들러는 `string`, `Buffer`, `null` 등 다양한 타입의 값을 반환하여 클라이언트에 응답할 수 있습니다.

**중요:** 일반 객체(`object`)를 반환하면 자동으로 JSON으로 변환되지 않습니다. JSON 응답을 보내려면 반드시 `JSON.stringify()`를 사용하여 문자열로 변환하고, `Content-Type` 헤더를 `application/json`으로 설정해야 합니다.

## 최종 우선순위

요청이 들어왔을 때 Xvelte는 다음 순서로 일치하는 엔드포인트 핸들러를 찾습니다.

1.  `app.get()` 등으로 등록된 **프로그래밍 방식 라우트**
2.  `src/routes` 폴더 내의 **파일 시스템 기반 라우트**

예를 들어, `app.get('/api/health', ...)`가 등록되어 있고 `src/routes/api/health/+server.ts` 파일에도 `GET` 핸들러가 존재한다면, `/api/health`로 GET 요청 시 `app.get()`으로 등록한 핸들러가 실행됩니다.