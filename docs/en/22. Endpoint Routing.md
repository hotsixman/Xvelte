# 22. Endpoint Routing

Xvelte provides two methods for creating server API endpoints: **programmatic** and **file-system based**. Both methods work in a similar way to Express.js, and when used together, the programmatic approach has higher priority.

## 1. Programmatic Routing (High Priority)

This method involves directly registering an endpoint handler using methods corresponding to HTTP methods on the `XvelteApp` instance. Routes registered here are checked before file-system based routes.

-   `app.get(path, handler)`
-   `app.post(path, handler)`
-   `app.put(path, handler)`
-   `app.delete(path, handler)`
-   `app.all(path, handler)`: Handles all methods

```ts
// src/app.ts (Application entry file)

// GET /api/items
app.get('/api/items', (event) => {
  const items = [{ id: 1, name: 'Xvelte' }];
  event.setHeader('Content-Type', 'application/json');
  return JSON.stringify(items);
});

// POST /api/items
app.post('/api/items', async (event) => {
  const newItem = await event.json();
  event.status = 201;
  event.setHeader('Content-Type', 'application/json');
  return JSON.stringify({ success: true, message: 'Item created' });
});
```

## 2. File-System Based Routing

This method involves creating a `+server.ts` file in the `src/routes` directory and exporting functions named after HTTP methods (in lowercase) to define endpoints.

### Basic Structure

You can define multiple method handlers in a single `+server.ts` file.

```typescript
// src/routes/api/todos/+server.ts

import type { RequestEvent } from '@hotsixman/xvelte';

// Temporary database
let todos = [{ id: 1, text: 'Study Xvelte' }];

// GET /api/todos
export function get(event: RequestEvent) {
    event.setHeader('Content-Type', 'application/json');
    return JSON.stringify(todos);
}

// POST /api/todos
export async function post(event: RequestEvent) {
    const { text } = await event.json();
    const newTodo = { id: Date.now(), text };
    todos.push(newTodo);

    event.status = 201; // Created
    event.setHeader('Content-Type', 'application/json');
    return JSON.stringify(newTodo);
}
```

### Dynamic Routing

You can handle dynamic parameters by using square brackets (`[]`) in the file path. The parameters can be accessed through the `event.params` object.

```typescript
// src/routes/api/todos/[id]/+server.ts

// DELETE /api/todos/:id
export function del(event: RequestEvent) {
    const id = Number(event.params.id);
    todos = todos.filter(todo => todo.id !== id);
    
    event.status = 204; // No Content
    return null;
}
```

**Note:** Since `delete` is a reserved keyword in JavaScript, the handler function is named `del`.

## `RequestEvent` and Handler Return Values

All endpoint handlers receive a `RequestEvent` object as an argument, which can be used to analyze the request and control the response. For more details, please refer to the [RequestEvent](./23. RequestEvent.md) document.

Handlers can return various types of values to respond to the client, such as `string`, `Buffer`, `null`, etc.

**Important:** Returning a plain object will not automatically be converted to JSON. To send a JSON response, you must use `JSON.stringify()` to convert it to a string and set the `Content-Type` header to `application/json`.

## Final Priority

When a request comes in, Xvelte finds a matching endpoint handler in the following order:

1.  **Programmatic routes** registered with `app.get()`, etc.
2.  **File-system based routes** within the `src/routes` folder

For example, if `app.get('/api/health', ...)` is registered and a `get` handler also exists in `src/routes/api/health/+server.ts`, the handler registered with `app.get()` will be executed for GET requests to `/api/health`.